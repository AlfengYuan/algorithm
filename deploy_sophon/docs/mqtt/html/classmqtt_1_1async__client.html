<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PahoMqttCpp: mqtt::async_client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pahologo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PahoMqttCpp
   </div>
   <div id="projectbrief">MQTT C++ Client for POSIX and Windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemqtt.html">mqtt</a></li><li class="navelem"><a class="el" href="classmqtt_1_1async__client.html">async_client</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">mqtt::async_client Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="async__client_8h_source.html">async_client.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for mqtt::async_client:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmqtt_1_1async__client.png" usemap="#mqtt::async_5Fclient_map" alt=""/>
  <map id="mqtt::async_5Fclient_map" name="mqtt::async_5Fclient_map">
<area href="classmqtt_1_1iasync__client.html" alt="mqtt::iasync_client" shape="rect" coords="0,0,113,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a47a444965a20ce8d44d5d10132b8e087"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a47a444965a20ce8d44d5d10132b8e087">ptr_t</a> = std::shared_ptr&lt; <a class="el" href="classmqtt_1_1async__client.html">async_client</a> &gt;</td></tr>
<tr class="separator:a47a444965a20ce8d44d5d10132b8e087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b832f2b74b7976547986103c64d137"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a26b832f2b74b7976547986103c64d137">consumer_queue_type</a> = std::unique_ptr&lt; <a class="el" href="classmqtt_1_1thread__queue.html">thread_queue</a>&lt; <a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> &gt; &gt;</td></tr>
<tr class="separator:a26b832f2b74b7976547986103c64d137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa78dcdc5ef2dda9da78732fd945463"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a6fa78dcdc5ef2dda9da78732fd945463">message_handler</a> = std::function&lt; void(<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>)&gt;</td></tr>
<tr class="separator:a6fa78dcdc5ef2dda9da78732fd945463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff9c44247a0063b93af82d7c21c2474"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#afff9c44247a0063b93af82d7c21c2474">connection_handler</a> = std::function&lt; void(const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;cause)&gt;</td></tr>
<tr class="separator:afff9c44247a0063b93af82d7c21c2474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6609824bce2c6f5e42b04e0b73702e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a6e6609824bce2c6f5e42b04e0b73702e">disconnected_handler</a> = std::function&lt; void(const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;, <a class="el" href="namespacemqtt.html#a2ac8994dbff700e61e5f756d54c6a1c7">ReasonCode</a>)&gt;</td></tr>
<tr class="separator:a6e6609824bce2c6f5e42b04e0b73702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573643b9fdf2f80fd6d5ac82b8e01d0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a573643b9fdf2f80fd6d5ac82b8e01d0a">update_connection_handler</a> = std::function&lt; bool(<a class="el" href="classmqtt_1_1connect__data.html">connect_data</a> &amp;)&gt;</td></tr>
<tr class="separator:a573643b9fdf2f80fd6d5ac82b8e01d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmqtt_1_1iasync__client"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmqtt_1_1iasync__client')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmqtt_1_1iasync__client.html">mqtt::iasync_client</a></td></tr>
<tr class="memitem:aee95659bed2446d0409ce33479f9cdad inherit pub_types_classmqtt_1_1iasync__client"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1iasync__client.html#aee95659bed2446d0409ce33479f9cdad">qos_collection</a> = std::vector&lt; int &gt;</td></tr>
<tr class="separator:aee95659bed2446d0409ce33479f9cdad inherit pub_types_classmqtt_1_1iasync__client"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae1c9326c10e7e954b3b30cbf4d06ea8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ae1c9326c10e7e954b3b30cbf4d06ea8d">async_client</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;serverURI, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;clientId, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;persistDir)</td></tr>
<tr class="separator:ae1c9326c10e7e954b3b30cbf4d06ea8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a443ee1420a9d058fcded62406190b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a9a443ee1420a9d058fcded62406190b4">async_client</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;serverURI, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;clientId, <a class="el" href="classmqtt_1_1iclient__persistence.html">iclient_persistence</a> *persistence=nullptr)</td></tr>
<tr class="separator:a9a443ee1420a9d058fcded62406190b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacf166a53c88bb9b80e0103d0710e89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#aeacf166a53c88bb9b80e0103d0710e89">async_client</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;serverURI, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;clientId, int maxBufferedMessages, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;persistDir)</td></tr>
<tr class="separator:aeacf166a53c88bb9b80e0103d0710e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78d2578ea52db0887323c8824429248"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#af78d2578ea52db0887323c8824429248">async_client</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;serverURI, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;clientId, int maxBufferedMessages, <a class="el" href="classmqtt_1_1iclient__persistence.html">iclient_persistence</a> *persistence=nullptr)</td></tr>
<tr class="separator:af78d2578ea52db0887323c8824429248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aa45c98f6ebf54bf9edefe07035280"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#aa0aa45c98f6ebf54bf9edefe07035280">async_client</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;serverURI, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;clientId, const <a class="el" href="classmqtt_1_1create__options.html">create_options</a> &amp;opts, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;persistDir)</td></tr>
<tr class="separator:aa0aa45c98f6ebf54bf9edefe07035280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f12c9e124ddb3ab53e82796720b2c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a57f12c9e124ddb3ab53e82796720b2c6">async_client</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;serverURI, const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;clientId, const <a class="el" href="classmqtt_1_1create__options.html">create_options</a> &amp;opts, <a class="el" href="classmqtt_1_1iclient__persistence.html">iclient_persistence</a> *persistence=nullptr)</td></tr>
<tr class="separator:a57f12c9e124ddb3ab53e82796720b2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42f0639330fffbfe8b9d010be301613"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ad42f0639330fffbfe8b9d010be301613">~async_client</a> () override</td></tr>
<tr class="separator:ad42f0639330fffbfe8b9d010be301613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b09cc4d4788420926725b7df00d3448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a8b09cc4d4788420926725b7df00d3448">set_callback</a> (<a class="el" href="classmqtt_1_1callback.html">callback</a> &amp;cb) override</td></tr>
<tr class="separator:a8b09cc4d4788420926725b7df00d3448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88e293c7e1431ff7a2f74d032b5fd4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ae88e293c7e1431ff7a2f74d032b5fd4b">disable_callbacks</a> () override</td></tr>
<tr class="separator:ae88e293c7e1431ff7a2f74d032b5fd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cac2ff52b354258c2ea4e829eae5e90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a9cac2ff52b354258c2ea4e829eae5e90">set_connected_handler</a> (<a class="el" href="classmqtt_1_1async__client.html#afff9c44247a0063b93af82d7c21c2474">connection_handler</a> cb)</td></tr>
<tr class="separator:a9cac2ff52b354258c2ea4e829eae5e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014aa813612bd6796c629906c09c9d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a014aa813612bd6796c629906c09c9d2a">set_connection_lost_handler</a> (<a class="el" href="classmqtt_1_1async__client.html#afff9c44247a0063b93af82d7c21c2474">connection_handler</a> cb)</td></tr>
<tr class="separator:a014aa813612bd6796c629906c09c9d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8956c48d810869e860afc78c082587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a2c8956c48d810869e860afc78c082587">set_disconnected_handler</a> (<a class="el" href="classmqtt_1_1async__client.html#a6e6609824bce2c6f5e42b04e0b73702e">disconnected_handler</a> cb)</td></tr>
<tr class="separator:a2c8956c48d810869e860afc78c082587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59082c398211f79c246bc890e48e11d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a59082c398211f79c246bc890e48e11d9">set_message_callback</a> (<a class="el" href="classmqtt_1_1async__client.html#a6fa78dcdc5ef2dda9da78732fd945463">message_handler</a> cb)</td></tr>
<tr class="separator:a59082c398211f79c246bc890e48e11d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6299c16d6f2189e140536f82708f3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#aed6299c16d6f2189e140536f82708f3d">set_update_connection_handler</a> (<a class="el" href="classmqtt_1_1async__client.html#a573643b9fdf2f80fd6d5ac82b8e01d0a">update_connection_handler</a> cb)</td></tr>
<tr class="separator:aed6299c16d6f2189e140536f82708f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee06a4438b2075de021bbf8d5b6b0c33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#aee06a4438b2075de021bbf8d5b6b0c33">connect</a> () override</td></tr>
<tr class="separator:aee06a4438b2075de021bbf8d5b6b0c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4546820d1ee0426c2964327c6d654a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#af4546820d1ee0426c2964327c6d654a0">connect</a> (<a class="el" href="classmqtt_1_1connect__options.html">connect_options</a> options) override</td></tr>
<tr class="separator:af4546820d1ee0426c2964327c6d654a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6599c1a530dda9fa66effb0d706d6795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a6599c1a530dda9fa66effb0d706d6795">connect</a> (<a class="el" href="classmqtt_1_1connect__options.html">connect_options</a> options, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb) override</td></tr>
<tr class="separator:a6599c1a530dda9fa66effb0d706d6795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68c924e65104b40488cba072597baeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ae68c924e65104b40488cba072597baeb">connect</a> (void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb) override</td></tr>
<tr class="separator:ae68c924e65104b40488cba072597baeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cad44caab9aa829745477b170eae3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a93cad44caab9aa829745477b170eae3d">reconnect</a> () override</td></tr>
<tr class="separator:a93cad44caab9aa829745477b170eae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376960f9e1fbe5e40136f2f07b22d780"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a376960f9e1fbe5e40136f2f07b22d780">disconnect</a> () override</td></tr>
<tr class="separator:a376960f9e1fbe5e40136f2f07b22d780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6e9ada464133778f0154da32eefc61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a2d6e9ada464133778f0154da32eefc61">disconnect</a> (<a class="el" href="classmqtt_1_1disconnect__options.html">disconnect_options</a> opts) override</td></tr>
<tr class="separator:a2d6e9ada464133778f0154da32eefc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ccd6989f8839a35954776de682a29b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a56ccd6989f8839a35954776de682a29b">disconnect</a> (int timeout) override</td></tr>
<tr class="separator:a56ccd6989f8839a35954776de682a29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56d21f49709f195e1af37becfc4e0ee"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:ad56d21f49709f195e1af37becfc4e0ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ad56d21f49709f195e1af37becfc4e0ee">disconnect</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout)</td></tr>
<tr class="separator:ad56d21f49709f195e1af37becfc4e0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cd2e2e1281312273ea0a5f18607f03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#aa7cd2e2e1281312273ea0a5f18607f03">disconnect</a> (int timeout, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb) override</td></tr>
<tr class="separator:aa7cd2e2e1281312273ea0a5f18607f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9175e2992ec07e0d27286f875ba107"><td class="memTemplParams" colspan="2">template&lt;class Rep , class Period &gt; </td></tr>
<tr class="memitem:a5f9175e2992ec07e0d27286f875ba107"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a5f9175e2992ec07e0d27286f875ba107">disconnect</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb)</td></tr>
<tr class="separator:a5f9175e2992ec07e0d27286f875ba107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9676f95c8b6c1b4a605d5fd8b8c251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#adf9676f95c8b6c1b4a605d5fd8b8c251">disconnect</a> (void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb) override</td></tr>
<tr class="separator:adf9676f95c8b6c1b4a605d5fd8b8c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac62c2c80ed3a1c32582b97e6e357ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#adac62c2c80ed3a1c32582b97e6e357ed">get_pending_delivery_token</a> (int msgID) const override</td></tr>
<tr class="separator:adac62c2c80ed3a1c32582b97e6e357ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec00d760cb3a6db6ac633c48365207d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#aec00d760cb3a6db6ac633c48365207d5">get_pending_delivery_tokens</a> () const override</td></tr>
<tr class="separator:aec00d760cb3a6db6ac633c48365207d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8105627f112a23e5c8067901cf1650a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a8105627f112a23e5c8067901cf1650a2">get_client_id</a> () const override</td></tr>
<tr class="separator:a8105627f112a23e5c8067901cf1650a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cc6dc75715f467c8c0556f0f0c6c04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ad2cc6dc75715f467c8c0556f0f0c6c04">get_server_uri</a> () const override</td></tr>
<tr class="separator:ad2cc6dc75715f467c8c0556f0f0c6c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cdafd9ae2375e822f3968c57c3bc65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ac4cdafd9ae2375e822f3968c57c3bc65">mqtt_version</a> () const noexcept</td></tr>
<tr class="separator:ac4cdafd9ae2375e822f3968c57c3bc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe2b8717b52d9b6c92f0ea8d89a3dbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#aefe2b8717b52d9b6c92f0ea8d89a3dbe">is_connected</a> () const override</td></tr>
<tr class="separator:aefe2b8717b52d9b6c92f0ea8d89a3dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa8d3dd5b88a5643dcd28e5069da8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a7fa8d3dd5b88a5643dcd28e5069da8a5">publish</a> (<a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a> <a class="el" href="classmqtt_1_1topic.html">topic</a>, const void *payload, size_t n, int qos, bool retained) override</td></tr>
<tr class="separator:a7fa8d3dd5b88a5643dcd28e5069da8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425e5e48369a523378b6c92de7bf4b85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a425e5e48369a523378b6c92de7bf4b85">publish</a> (<a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a> <a class="el" href="classmqtt_1_1topic.html">topic</a>, const void *payload, size_t n) override</td></tr>
<tr class="separator:a425e5e48369a523378b6c92de7bf4b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb723eb44fccf64e18b2a25acd938b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#afcb723eb44fccf64e18b2a25acd938b5">publish</a> (<a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a> <a class="el" href="classmqtt_1_1topic.html">topic</a>, <a class="el" href="namespacemqtt.html#ab71322102b35c39c873ca7743431229d">binary_ref</a> payload, int qos, bool retained) override</td></tr>
<tr class="separator:afcb723eb44fccf64e18b2a25acd938b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804df67eff69884958d897294194a351"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a804df67eff69884958d897294194a351">publish</a> (<a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a> <a class="el" href="classmqtt_1_1topic.html">topic</a>, <a class="el" href="namespacemqtt.html#ab71322102b35c39c873ca7743431229d">binary_ref</a> payload) override</td></tr>
<tr class="separator:a804df67eff69884958d897294194a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8b3e11497b2aa1204f1ca380e81490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a3a8b3e11497b2aa1204f1ca380e81490">publish</a> (<a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a> <a class="el" href="classmqtt_1_1topic.html">topic</a>, const void *payload, size_t n, int qos, bool retained, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb) override</td></tr>
<tr class="separator:a3a8b3e11497b2aa1204f1ca380e81490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dbbe800b37c395e45aeb5ddd725ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#af1dbbe800b37c395e45aeb5ddd725ffd">publish</a> (<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> msg) override</td></tr>
<tr class="separator:af1dbbe800b37c395e45aeb5ddd725ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ce15b7a304e7f091db2642308a91e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a06ce15b7a304e7f091db2642308a91e2">publish</a> (<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> msg, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb) override</td></tr>
<tr class="separator:a06ce15b7a304e7f091db2642308a91e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3e65d1be977116bdd997f7248e77db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a2d3e65d1be977116bdd997f7248e77db">subscribe</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;topicFilter, int qos, const <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &amp;opts=<a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a>(), const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:a2d3e65d1be977116bdd997f7248e77db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475c26ed5e91b1fc24a484666d8cdefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a475c26ed5e91b1fc24a484666d8cdefa">subscribe</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;topicFilter, int qos, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb, const <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &amp;opts=<a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a>(), const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:a475c26ed5e91b1fc24a484666d8cdefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e2ed5fc9f649a9dda145e0e69ec929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a56e2ed5fc9f649a9dda145e0e69ec929">subscribe</a> (<a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a> topicFilters, const <a class="el" href="classmqtt_1_1iasync__client.html#aee95659bed2446d0409ce33479f9cdad">qos_collection</a> &amp;qos, const std::vector&lt; <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &gt; &amp;opts=std::vector&lt; <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &gt;(), const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:a56e2ed5fc9f649a9dda145e0e69ec929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930bb9f020ed1bc86ef1cf870f232b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a930bb9f020ed1bc86ef1cf870f232b3d">subscribe</a> (<a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a> topicFilters, const <a class="el" href="classmqtt_1_1iasync__client.html#aee95659bed2446d0409ce33479f9cdad">qos_collection</a> &amp;qos, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb, const std::vector&lt; <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &gt; &amp;opts=std::vector&lt; <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &gt;(), const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:a930bb9f020ed1bc86ef1cf870f232b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da729c78703ff863f127e4e2ba7506a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a7da729c78703ff863f127e4e2ba7506a">unsubscribe</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;topicFilter, const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:a7da729c78703ff863f127e4e2ba7506a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69856c842407d80fe10f0364e347f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ab69856c842407d80fe10f0364e347f27">unsubscribe</a> (<a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a> topicFilters, const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:ab69856c842407d80fe10f0364e347f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd93e4b4a390d1421862378739801fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#abd93e4b4a390d1421862378739801fea">unsubscribe</a> (<a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a> topicFilters, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb, const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:abd93e4b4a390d1421862378739801fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac989934222378d7a631679ce774b4a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ac989934222378d7a631679ce774b4a27">unsubscribe</a> (const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;topicFilter, void *userContext, <a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;cb, const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;props=<a class="el" href="classmqtt_1_1properties.html">properties</a>()) override</td></tr>
<tr class="separator:ac989934222378d7a631679ce774b4a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37da8fd86b399301f2f5d5f3b239efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#af37da8fd86b399301f2f5d5f3b239efb">start_consuming</a> () override</td></tr>
<tr class="separator:af37da8fd86b399301f2f5d5f3b239efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52081856f2406e7d76ccb5450c5d45ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a52081856f2406e7d76ccb5450c5d45ca">stop_consuming</a> () override</td></tr>
<tr class="separator:a52081856f2406e7d76ccb5450c5d45ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931bb5c47e540f66774ae40ae4aa3e32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a931bb5c47e540f66774ae40ae4aa3e32">consume_message</a> () override</td></tr>
<tr class="separator:a931bb5c47e540f66774ae40ae4aa3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34636569902d3fb5994891cc47882a81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a34636569902d3fb5994891cc47882a81">try_consume_message</a> (<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> *msg) override</td></tr>
<tr class="separator:a34636569902d3fb5994891cc47882a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5613bf9226d6ad9b8dcf15a238c18c23"><td class="memTemplParams" colspan="2">template&lt;typename Rep , class Period &gt; </td></tr>
<tr class="memitem:a5613bf9226d6ad9b8dcf15a238c18c23"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a5613bf9226d6ad9b8dcf15a238c18c23">try_consume_message_for</a> (<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> *msg, const std::chrono::duration&lt; Rep, Period &gt; &amp;relTime)</td></tr>
<tr class="separator:a5613bf9226d6ad9b8dcf15a238c18c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9534048df4f4b6a0082c60c4fa477c12"><td class="memTemplParams" colspan="2">template&lt;typename Rep , class Period &gt; </td></tr>
<tr class="memitem:a9534048df4f4b6a0082c60c4fa477c12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a9534048df4f4b6a0082c60c4fa477c12">try_consume_message_for</a> (const std::chrono::duration&lt; Rep, Period &gt; &amp;relTime)</td></tr>
<tr class="separator:a9534048df4f4b6a0082c60c4fa477c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc99d5afd5d35aeb0888ff6c08b9ed0"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:a8bc99d5afd5d35aeb0888ff6c08b9ed0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a8bc99d5afd5d35aeb0888ff6c08b9ed0">try_consume_message_until</a> (<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> *msg, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;absTime)</td></tr>
<tr class="separator:a8bc99d5afd5d35aeb0888ff6c08b9ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d315b0885450ed5f33d05002de5635c"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:a2d315b0885450ed5f33d05002de5635c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#a2d315b0885450ed5f33d05002de5635c">try_consume_message_until</a> (const std::chrono::time_point&lt; Clock, Duration &gt; &amp;absTime)</td></tr>
<tr class="separator:a2d315b0885450ed5f33d05002de5635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmqtt_1_1iasync__client"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmqtt_1_1iasync__client')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmqtt_1_1iasync__client.html">mqtt::iasync_client</a></td></tr>
<tr class="memitem:a423bdce3b018de4597f773402f3eb360 inherit pub_methods_classmqtt_1_1iasync__client"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1iasync__client.html#a423bdce3b018de4597f773402f3eb360">~iasync_client</a> ()</td></tr>
<tr class="separator:a423bdce3b018de4597f773402f3eb360 inherit pub_methods_classmqtt_1_1iasync__client"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad1520136c41afff5cd24bf19d9bf76e5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1async__client.html#ad1520136c41afff5cd24bf19d9bf76e5">token</a></td></tr>
<tr class="separator:ad1520136c41afff5cd24bf19d9bf76e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Client for talking to an MQTT server using non-blocking methods that allow an operation to run in the background.</p>
<p>The location of the server is specified as a URI string with the following schemas supported to specify the type and security used for the connection: </p><ul>
<li><em>"mqtt://"</em> - A standard (insecure) connection over TCP. (Also, "tcp://") </li>
<li><em>"mqtts://"</em> - A secure connection using SSL/TLS sockets. (Also "ssl://") </li>
<li><em>"ws://"</em> - A standard (insecure) WebSocket connection. </li>
<li><em>"wss://</em> - A secure websocket connection using SSL/TLS.</li>
</ul>
<p>The secure connection types assume that the library was built with OpenSSL support, otherwise requesting a secure conection will result in an error.</p>
<p>The communication methods of this class - <code><a class="el" href="classmqtt_1_1async__client.html#aee06a4438b2075de021bbf8d5b6b0c33">connect()</a></code>, <code><a class="el" href="classmqtt_1_1async__client.html#a7fa8d3dd5b88a5643dcd28e5069da8a5">publish()</a></code>, <code><a class="el" href="classmqtt_1_1async__client.html#a2d3e65d1be977116bdd997f7248e77db">subscribe()</a></code>, etc. - are all asynchronous. They create the request for the server, but return imediately, before a response is received back from the server.</p>
<p>These methods return a <code>Token</code> to the caller which is akin to a C++ std::future. The caller can keep the Token, then use it later to block until the asynchronous operation is complete and retrieve the result of the operation, including any response from the server.</p>
<p>Alternately, the application can choose to set callbacks to be fired when each operation completes. This can be used to create an event-driven architecture, but is more complex in that it forces the user to avoid any blocking operations and manually handle thread synchronization (since the callbacks run in a separate thread managed by the library). </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a47a444965a20ce8d44d5d10132b8e087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a444965a20ce8d44d5d10132b8e087">&#9670;&nbsp;</a></span>ptr_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1async__client.html#a47a444965a20ce8d44d5d10132b8e087">mqtt::async_client::ptr_t</a> =  std::shared_ptr&lt;<a class="el" href="classmqtt_1_1async__client.html">async_client</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smart/shared pointer for an object of this class </p>

</div>
</div>
<a id="a26b832f2b74b7976547986103c64d137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b832f2b74b7976547986103c64d137">&#9670;&nbsp;</a></span>consumer_queue_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1async__client.html#a26b832f2b74b7976547986103c64d137">mqtt::async_client::consumer_queue_type</a> =  std::unique_ptr&lt;<a class="el" href="classmqtt_1_1thread__queue.html">thread_queue</a>&lt;<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for a thread-safe queue to consume messages synchronously </p>

</div>
</div>
<a id="a6fa78dcdc5ef2dda9da78732fd945463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa78dcdc5ef2dda9da78732fd945463">&#9670;&nbsp;</a></span>message_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1async__client.html#a6fa78dcdc5ef2dda9da78732fd945463">mqtt::async_client::message_handler</a> =  std::function&lt;void(<a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handler type for registering an individual message callback </p>

</div>
</div>
<a id="afff9c44247a0063b93af82d7c21c2474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff9c44247a0063b93af82d7c21c2474">&#9670;&nbsp;</a></span>connection_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1async__client.html#afff9c44247a0063b93af82d7c21c2474">mqtt::async_client::connection_handler</a> =  std::function&lt;void(const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a>&amp; cause)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handler type for when a connecion is made or lost </p>

</div>
</div>
<a id="a6e6609824bce2c6f5e42b04e0b73702e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6609824bce2c6f5e42b04e0b73702e">&#9670;&nbsp;</a></span>disconnected_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1async__client.html#a6e6609824bce2c6f5e42b04e0b73702e">mqtt::async_client::disconnected_handler</a> =  std::function&lt;void(const <a class="el" href="classmqtt_1_1properties.html">properties</a>&amp;, <a class="el" href="namespacemqtt.html#a2ac8994dbff700e61e5f756d54c6a1c7">ReasonCode</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handler type for when a disconnect packet is received </p>

</div>
</div>
<a id="a573643b9fdf2f80fd6d5ac82b8e01d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573643b9fdf2f80fd6d5ac82b8e01d0a">&#9670;&nbsp;</a></span>update_connection_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1async__client.html#a573643b9fdf2f80fd6d5ac82b8e01d0a">mqtt::async_client::update_connection_handler</a> =  std::function&lt;bool(<a class="el" href="classmqtt_1_1connect__data.html">connect_data</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handler for updaing connection data before an auto-reconnect. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae1c9326c10e7e954b3b30cbf4d06ea8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c9326c10e7e954b3b30cbf4d06ea8d">&#9670;&nbsp;</a></span>async_client() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mqtt::async_client::async_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>serverURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>clientId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>persistDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classmqtt_1_1async__client.html">async_client</a> that can be used to communicate with an MQTT server. This uses file-based persistence in the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serverURI</td><td>the address of the server to connect to, specified as a URI. </td></tr>
    <tr><td class="paramname">clientId</td><td>a client identifier that is unique on the server being connected to </td></tr>
    <tr><td class="paramname">persistDir</td><td>The directory to use for persistence data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if an argument is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a443ee1420a9d058fcded62406190b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a443ee1420a9d058fcded62406190b4">&#9670;&nbsp;</a></span>async_client() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mqtt::async_client::async_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>serverURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>clientId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iclient__persistence.html">iclient_persistence</a> *&#160;</td>
          <td class="paramname"><em>persistence</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classmqtt_1_1async__client.html">async_client</a> that can be used to communicate with an MQTT server. This allows the caller to specify a user-defined persistence object, or use no persistence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serverURI</td><td>the address of the server to connect to, specified as a URI. </td></tr>
    <tr><td class="paramname">clientId</td><td>a client identifier that is unique on the server being connected to </td></tr>
    <tr><td class="paramname">persistence</td><td>The user persistence structure. If this is null, then no persistence is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if an argument is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeacf166a53c88bb9b80e0103d0710e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacf166a53c88bb9b80e0103d0710e89">&#9670;&nbsp;</a></span>async_client() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mqtt::async_client::async_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>serverURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>clientId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferedMessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>persistDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classmqtt_1_1async__client.html">async_client</a> that can be used to communicate with an MQTT server, which allows for off-line message buffering. This uses file-based persistence in the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serverURI</td><td>the address of the server to connect to, specified as a URI. </td></tr>
    <tr><td class="paramname">clientId</td><td>a client identifier that is unique on the server being connected to </td></tr>
    <tr><td class="paramname">maxBufferedMessages</td><td>the maximum number of messages allowed to be buffered while not connected </td></tr>
    <tr><td class="paramname">persistDir</td><td>The directory to use for persistence data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if an argument is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af78d2578ea52db0887323c8824429248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78d2578ea52db0887323c8824429248">&#9670;&nbsp;</a></span>async_client() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mqtt::async_client::async_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>serverURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>clientId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferedMessages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iclient__persistence.html">iclient_persistence</a> *&#160;</td>
          <td class="paramname"><em>persistence</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classmqtt_1_1async__client.html">async_client</a> that can be used to communicate with an MQTT server, which allows for off-line message buffering. This allows the caller to specify a user-defined persistence object, or use no persistence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serverURI</td><td>the address of the server to connect to, specified as a URI. </td></tr>
    <tr><td class="paramname">clientId</td><td>a client identifier that is unique on the server being connected to </td></tr>
    <tr><td class="paramname">maxBufferedMessages</td><td>the maximum number of messages allowed to be buffered while not connected </td></tr>
    <tr><td class="paramname">persistence</td><td>The user persistence structure. If this is null, then no persistence is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if an argument is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0aa45c98f6ebf54bf9edefe07035280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aa45c98f6ebf54bf9edefe07035280">&#9670;&nbsp;</a></span>async_client() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mqtt::async_client::async_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>serverURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>clientId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1create__options.html">create_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>persistDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classmqtt_1_1async__client.html">async_client</a> that can be used to communicate with an MQTT server, which allows for off-line message buffering. This uses file-based persistence in the specified directory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serverURI</td><td>the address of the server to connect to, specified as a URI. </td></tr>
    <tr><td class="paramname">clientId</td><td>a client identifier that is unique on the server being connected to </td></tr>
    <tr><td class="paramname">opts</td><td>The create options </td></tr>
    <tr><td class="paramname">persistDir</td><td>The directory to use for persistence data </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if an argument is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57f12c9e124ddb3ab53e82796720b2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f12c9e124ddb3ab53e82796720b2c6">&#9670;&nbsp;</a></span>async_client() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mqtt::async_client::async_client </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>serverURI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>clientId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1create__options.html">create_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iclient__persistence.html">iclient_persistence</a> *&#160;</td>
          <td class="paramname"><em>persistence</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an <a class="el" href="classmqtt_1_1async__client.html">async_client</a> that can be used to communicate with an MQTT server, which allows for off-line message buffering. This allows the caller to specify a user-defined persistence object, or use no persistence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serverURI</td><td>the address of the server to connect to, specified as a URI. </td></tr>
    <tr><td class="paramname">clientId</td><td>a client identifier that is unique on the server being connected to </td></tr>
    <tr><td class="paramname">opts</td><td>The create options </td></tr>
    <tr><td class="paramname">persistence</td><td>The user persistence structure. If this is null, then no persistence is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>if an argument is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad42f0639330fffbfe8b9d010be301613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42f0639330fffbfe8b9d010be301613">&#9670;&nbsp;</a></span>~async_client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mqtt::async_client::~async_client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8b09cc4d4788420926725b7df00d3448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b09cc4d4788420926725b7df00d3448">&#9670;&nbsp;</a></span>set_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::set_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1callback.html">callback</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a callback listener to use for events that happen asynchronously. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>callback receiver which will be invoked for certain asynchronous events </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#ab02592cece3ea4f17164bf56ce7a16f2">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="ae88e293c7e1431ff7a2f74d032b5fd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88e293c7e1431ff7a2f74d032b5fd4b">&#9670;&nbsp;</a></span>disable_callbacks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::disable_callbacks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops callbacks. This is not normally called by the application. It should be used cautiously as it may cause the application to lose messages. </p>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a137e34c3acb046deac069cd689459447">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a9cac2ff52b354258c2ea4e829eae5e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cac2ff52b354258c2ea4e829eae5e90">&#9670;&nbsp;</a></span>set_connected_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::set_connected_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1async__client.html#afff9c44247a0063b93af82d7c21c2474">connection_handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for when a connection is made. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback functor for when the connection is made. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a014aa813612bd6796c629906c09c9d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014aa813612bd6796c629906c09c9d2a">&#9670;&nbsp;</a></span>set_connection_lost_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::set_connection_lost_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1async__client.html#afff9c44247a0063b93af82d7c21c2474">connection_handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for when a connection is lost. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback functor for when the connection is lost. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c8956c48d810869e860afc78c082587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8956c48d810869e860afc78c082587">&#9670;&nbsp;</a></span>set_disconnected_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::set_disconnected_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1async__client.html#a6e6609824bce2c6f5e42b04e0b73702e">disconnected_handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback for when a disconnect packet is received from the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>Callback for when the disconnect packet is received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59082c398211f79c246bc890e48e11d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59082c398211f79c246bc890e48e11d9">&#9670;&nbsp;</a></span>set_message_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::set_message_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1async__client.html#a6fa78dcdc5ef2dda9da78732fd945463">message_handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the callback for when a message arrives from the broker. Note that the application can only have one message handler which can be installed individually using this method, or installled as a listener object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback functor to register with the library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed6299c16d6f2189e140536f82708f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6299c16d6f2189e140536f82708f3d">&#9670;&nbsp;</a></span>set_update_connection_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::set_update_connection_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1async__client.html#a573643b9fdf2f80fd6d5ac82b8e01d0a">update_connection_handler</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a callback to allow the application to update the connection data on automatic reconnects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The callback functor to register with the library. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee06a4438b2075de021bbf8d5b6b0c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee06a4438b2075de021bbf8d5b6b0c33">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::connect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connects to an MQTT server using the default options. </p><dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the connect to complete. The token will be passed to any callback that has been set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for non security related problems </td></tr>
    <tr><td class="paramname"><a class="el" href="classmqtt_1_1security__exception.html">security_exception</a></td><td>for security related problems </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a21c51c547dbc75fcd45b5ab87523f5e1">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="af4546820d1ee0426c2964327c6d654a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4546820d1ee0426c2964327c6d654a0">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1connect__options.html">connect_options</a>&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connects to an MQTT server using the provided connect options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>a set of connection parameters that override the defaults. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the connect to complete. The token will be passed to any callback that has been set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for non security related problems </td></tr>
    <tr><td class="paramname"><a class="el" href="classmqtt_1_1security__exception.html">security_exception</a></td><td>for security related problems </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#acfe9902e93ce9e8c80f5d13049df3289">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a6599c1a530dda9fa66effb0d706d6795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6599c1a530dda9fa66effb0d706d6795">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1connect__options.html">connect_options</a>&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Connects to an MQTT server using the specified options. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">options</td><td>a set of connection parameters that override the defaults. </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>callback listener that will be notified when the connect completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the connect to complete. The token will be passed to any callback that has been set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for non security related problems </td></tr>
    <tr><td class="paramname"><a class="el" href="classmqtt_1_1security__exception.html">security_exception</a></td><td>for security related problems </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a3cd5b23ef0ade37a574a82a603c07b95">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="ae68c924e65104b40488cba072597baeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68c924e65104b40488cba072597baeb">&#9670;&nbsp;</a></span>connect() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::connect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>callback listener that will be notified when the connect completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the connect to complete. The token will be passed to any callback that has been set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for non security related problems </td></tr>
    <tr><td class="paramname"><a class="el" href="classmqtt_1_1security__exception.html">security_exception</a></td><td>for security related problems </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a90b1e036050d0e3c9628f21bc74c5ac2">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a93cad44caab9aa829745477b170eae3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cad44caab9aa829745477b170eae3d">&#9670;&nbsp;</a></span>reconnect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::reconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reconnects the client using options from the previous connect. The client must have previously called <a class="el" href="classmqtt_1_1async__client.html#aee06a4438b2075de021bbf8d5b6b0c33">connect()</a> for this to work. </p><dl class="section return"><dt>Returns</dt><dd>token used to track the progress of the reconnect. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#aba2b3630f09fc47089d8487c6c6cf7cc">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a376960f9e1fbe5e40136f2f07b22d780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376960f9e1fbe5e40136f2f07b22d780">&#9670;&nbsp;</a></span>disconnect() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from the server. </p><dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the disconnect to complete. The token will be passed to any callback that has been set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for problems encountered while disconnecting </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#af6210f0a971f093fca297e3c8677132a">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a2d6e9ada464133778f0154da32eefc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6e9ada464133778f0154da32eefc61">&#9670;&nbsp;</a></span>disconnect() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1disconnect__options.html">disconnect_options</a>&#160;</td>
          <td class="paramname"><em>opts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opts</td><td>Options for disconnecting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the disconnect to complete. The token will be passed to any callback that has been set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for problems encountered while disconnecting </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#aa86156916f955141d6255592c0670330">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a56ccd6989f8839a35954776de682a29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ccd6989f8839a35954776de682a29b">&#9670;&nbsp;</a></span>disconnect() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::disconnect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the amount of time in milliseconds to allow for existing work to finish before disconnecting. A value of zero or less means the client will not quiesce. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Token used to track and wait for disconnect to complete. The token will be passed to the callback methods if a callback is set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for problems encountered while disconnecting </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#afca077c741725367b9f2d2299ebe6aa8">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="ad56d21f49709f195e1af37becfc4e0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56d21f49709f195e1af37becfc4e0ee">&#9670;&nbsp;</a></span>disconnect() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::disconnect </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the amount of time in milliseconds to allow for existing work to finish before disconnecting. A value of zero or less means the client will not quiesce. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Token used to track and wait for disconnect to complete. The token will be passed to the callback methods if a callback is set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for problems encountered while disconnecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7cd2e2e1281312273ea0a5f18607f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cd2e2e1281312273ea0a5f18607f03">&#9670;&nbsp;</a></span>disconnect() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::disconnect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the amount of time in milliseconds to allow for existing work to finish before disconnecting. A value of zero or less means the client will not quiesce. </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>callback listener that will be notified when the disconnect completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token_ptr Token used to track and wait for disconnect to complete. The token will be passed to the callback methods if a callback is set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for problems encountered while disconnecting </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#af0765c3d5b9890ec6fb732339a409489">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a5f9175e2992ec07e0d27286f875ba107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9175e2992ec07e0d27286f875ba107">&#9670;&nbsp;</a></span>disconnect() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::disconnect </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>the amount of time in milliseconds to allow for existing work to finish before disconnecting. A value of zero or less means the client will not quiesce. </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>callback listener that will be notified when the disconnect completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token_ptr Token used to track and wait for disconnect to complete. The token will be passed to the callback methods if a callback is set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for problems encountered while disconnecting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf9676f95c8b6c1b4a605d5fd8b8c251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9676f95c8b6c1b4a605d5fd8b8c251">&#9670;&nbsp;</a></span>disconnect() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::disconnect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disconnects from the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>callback listener that will be notified when the disconnect completes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token_ptr Token used to track and wait for disconnect to complete. The token will be passed to the callback methods if a callback is set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>for problems encountered while disconnecting </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#ab0bc5689995d3755ae29d75a3e8d7a1b">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="adac62c2c80ed3a1c32582b97e6e357ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac62c2c80ed3a1c32582b97e6e357ed">&#9670;&nbsp;</a></span>get_pending_delivery_token()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::get_pending_delivery_token </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>msgID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the delivery token for the specified message ID. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmqtt_1_1delivery__token.html">delivery_token</a> </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a4be5917b3f0d0ed0347f50446bc034d9">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="aec00d760cb3a6db6ac633c48365207d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec00d760cb3a6db6ac633c48365207d5">&#9670;&nbsp;</a></span>get_pending_delivery_tokens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a>&gt; mqtt::async_client::get_pending_delivery_tokens </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the delivery tokens for any outstanding publish operations. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmqtt_1_1delivery__token.html">delivery_token</a>[] </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#acd75b0c39458f65ca02ec37bd8c70f5a">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a8105627f112a23e5c8067901cf1650a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8105627f112a23e5c8067901cf1650a2">&#9670;&nbsp;</a></span>get_client_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> mqtt::async_client::get_client_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the client ID used by this client. </p><dl class="section return"><dt>Returns</dt><dd>The client ID used by this client. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a984c922348948b9e57f41d77a0487403">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="ad2cc6dc75715f467c8c0556f0f0c6c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cc6dc75715f467c8c0556f0f0c6c04">&#9670;&nbsp;</a></span>get_server_uri()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> mqtt::async_client::get_server_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the address of the server used by this client. </p><dl class="section return"><dt>Returns</dt><dd>The server's address, as a URI String. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a18a9a1dba6ef043c09f49f1be75f297b">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="ac4cdafd9ae2375e822f3968c57c3bc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cdafd9ae2375e822f3968c57c3bc65">&#9670;&nbsp;</a></span>mqtt_version()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int mqtt::async_client::mqtt_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the MQTT version used by the client. </p><dl class="section return"><dt>Returns</dt><dd>The MQTT version used by the client <ul>
<li>MQTTVERSION_DEFAULT (0) = default: start with 3.1.1, and if that fails, fall back to 3.1 </li>
<li>MQTTVERSION_3_1 (3) = only try version 3.1 </li>
<li>MQTTVERSION_3_1_1 (4) = only try version 3.1.1 </li>
<li>MQTTVERSION_5 (5) = only try version 5 </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aefe2b8717b52d9b6c92f0ea8d89a3dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe2b8717b52d9b6c92f0ea8d89a3dbe">&#9670;&nbsp;</a></span>is_connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mqtt::async_client::is_connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if this client is currently connected to the server. </p><dl class="section return"><dt>Returns</dt><dd>true if connected, false otherwise. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a2c486e40ac2c91890d7ae40ef5223c92">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a7fa8d3dd5b88a5643dcd28e5069da8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa8d3dd5b88a5643dcd28e5069da8a5">&#9670;&nbsp;</a></span>publish() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a>&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retained</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publishes a message to a topic on the server </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>The topic to deliver the message to </td></tr>
    <tr><td class="paramname">payload</td><td>the bytes to use as the message payload </td></tr>
    <tr><td class="paramname">n</td><td>the number of bytes in the payload </td></tr>
    <tr><td class="paramname">qos</td><td>the Quality of Service to deliver the message at. Valid values are 0, 1 or 2. </td></tr>
    <tr><td class="paramname">retained</td><td>whether or not this message should be retained by the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the publish to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#ace79b81482256ee2c8bb26ad261d3a64">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a425e5e48369a523378b6c92de7bf4b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425e5e48369a523378b6c92de7bf4b85">&#9670;&nbsp;</a></span>publish() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a>&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publishes a message to a topic on the server </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>The topic to deliver the message to </td></tr>
    <tr><td class="paramname">payload</td><td>the bytes to use as the message payload </td></tr>
    <tr><td class="paramname">n</td><td>the number of bytes in the payload </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the publish to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a4ac1db0b2d34fda55ee7304cecda87b0">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="afcb723eb44fccf64e18b2a25acd938b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb723eb44fccf64e18b2a25acd938b5">&#9670;&nbsp;</a></span>publish() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a>&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#ab71322102b35c39c873ca7743431229d">binary_ref</a>&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retained</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publishes a message to a topic on the server </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>The topic to deliver the message to </td></tr>
    <tr><td class="paramname">payload</td><td>the bytes to use as the message payload </td></tr>
    <tr><td class="paramname">qos</td><td>the Quality of Service to deliver the message at. Valid values are 0, 1 or 2. </td></tr>
    <tr><td class="paramname">retained</td><td>whether or not this message should be retained by the server. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the publish to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a979e6283426180926f9357b392593db2">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a804df67eff69884958d897294194a351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a804df67eff69884958d897294194a351">&#9670;&nbsp;</a></span>publish() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a>&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#ab71322102b35c39c873ca7743431229d">binary_ref</a>&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publishes a message to a topic on the server </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>The topic to deliver the message to </td></tr>
    <tr><td class="paramname">payload</td><td>the bytes to use as the message payload </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the publish to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#ac5190486cc5570afb1b01276fff3eb00">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a3a8b3e11497b2aa1204f1ca380e81490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8b3e11497b2aa1204f1ca380e81490">&#9670;&nbsp;</a></span>publish() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#ae2065a9eafa3224bce55768fad02749a">string_ref</a>&#160;</td>
          <td class="paramname"><em>topic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retained</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publishes a message to a topic on the server </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topic</td><td>The topic to deliver the message to </td></tr>
    <tr><td class="paramname">payload</td><td>the bytes to use as the message payload </td></tr>
    <tr><td class="paramname">n</td><td>the number of bytes in the payload </td></tr>
    <tr><td class="paramname">qos</td><td>the Quality of Service to deliver the message at. Valid values are 0, 1 or 2. </td></tr>
    <tr><td class="paramname">retained</td><td>whether or not this message should be retained by the server. </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the publish to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a4491592f64dd5f32c0c1ee097cd12bb7">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="af1dbbe800b37c395e45aeb5ddd725ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dbbe800b37c395e45aeb5ddd725ffd">&#9670;&nbsp;</a></span>publish() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publishes a message to a topic on the server Takes an Message message and delivers it to the server at the requested quality of service. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message to deliver to the server </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the publish to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a571bfa072520854502370e896bb0ce58">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a06ce15b7a304e7f091db2642308a91e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ce15b7a304e7f091db2642308a91e2">&#9670;&nbsp;</a></span>publish() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#af0ae39eb0c0473cb83d482d6425288e3">delivery_token_ptr</a> mqtt::async_client::publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a>&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publishes a message to a topic on the server. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>the message to deliver to the server </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>callback optional listener that will be notified when message delivery has completed to the requested quality of service </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the publish to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a0a209522dfbed3c6c1ecfe59383e6138">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a2d3e65d1be977116bdd997f7248e77db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3e65d1be977116bdd997f7248e77db">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>topicFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to a topic, which may include wildcards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilter</td><td>the topic to subscribe to, which can include wildcards. </td></tr>
    <tr><td class="paramname">qos</td><td>The quality of service for the subscription </td></tr>
    <tr><td class="paramname">opts</td><td>The MQTT v5 subscribe options for the topic </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the subscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#ad10711bae26bb675f168fa6f951d9014">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a475c26ed5e91b1fc24a484666d8cdefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475c26ed5e91b1fc24a484666d8cdefa">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>topicFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code><a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to a topic, which may include wildcards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilter</td><td>the topic to subscribe to, which can include wildcards. </td></tr>
    <tr><td class="paramname">qos</td><td>the maximum quality of service at which to subscribe. Messages published at a lower quality of service will be received at the published QoS. Messages published at a higher quality of service will be received using the QoS specified on the subscribe. </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>listener that will be notified when subscribe has completed </td></tr>
    <tr><td class="paramname">opts</td><td>The MQTT v5 subscribe options for the topic </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the subscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#ab1220a28416e6b6a940cfe8b2a16559f">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a56e2ed5fc9f649a9dda145e0e69ec929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e2ed5fc9f649a9dda145e0e69ec929">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a>&#160;</td>
          <td class="paramname"><em>topicFilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1iasync__client.html#aee95659bed2446d0409ce33479f9cdad">qos_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code>std::vector&lt;&#160;<a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribe to multiple topics, each of which may include wildcards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilters</td><td></td></tr>
    <tr><td class="paramname">qos</td><td>the maximum quality of service at which to subscribe. Messages published at a lower quality of service will be received at the published QoS. Messages published at a higher quality of service will be received using the QoS specified on the subscribe. </td></tr>
    <tr><td class="paramname">opts</td><td>The MQTT v5 subscribe options (one for each topic) </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the subscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a6645594b90ef699d100e35efc434d2c8">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a930bb9f020ed1bc86ef1cf870f232b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930bb9f020ed1bc86ef1cf870f232b3d">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a>&#160;</td>
          <td class="paramname"><em>topicFilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1iasync__client.html#aee95659bed2446d0409ce33479f9cdad">qos_collection</a> &amp;&#160;</td>
          <td class="paramname"><em>qos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>opts</em> = <code>std::vector&lt;&#160;<a class="el" href="classmqtt_1_1subscribe__options.html">subscribe_options</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes to multiple topics, each of which may include wildcards. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilters</td><td></td></tr>
    <tr><td class="paramname">qos</td><td>the maximum quality of service at which to subscribe. Messages published at a lower quality of service will be received at the published QoS. Messages published at a higher quality of service will be received using the QoS specified on the subscribe. </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>listener that will be notified when subscribe has completed </td></tr>
    <tr><td class="paramname">opts</td><td>The MQTT v5 subscribe options (one for each topic) </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the subscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a99b9b631bc9542013516ee9b848cc1ca">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a7da729c78703ff863f127e4e2ba7506a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da729c78703ff863f127e4e2ba7506a">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>topicFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests the server unsubscribe the client from a topic. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilter</td><td>the topic to unsubscribe from. It must match a topicFilter specified on an earlier subscribe. </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the unsubscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a77529e8bd58cd30b8a7cd449b600a9a9">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="ab69856c842407d80fe10f0364e347f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69856c842407d80fe10f0364e347f27">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a>&#160;</td>
          <td class="paramname"><em>topicFilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests the server unsubscribe the client from one or more topics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilters</td><td>one or more topics to unsubscribe from. Each topicFilter must match one specified on an earlier subscribe. </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the unsubscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a26764a46be682afaab1b01ee73907c35">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="abd93e4b4a390d1421862378739801fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd93e4b4a390d1421862378739801fea">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::unsubscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#a47ab37f80984b64e4a0b76d4367a22ec">const_string_collection_ptr</a>&#160;</td>
          <td class="paramname"><em>topicFilters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests the server unsubscribe the client from one or more topics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilters</td><td></td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>listener that will be notified when unsubscribe has completed </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the unsubscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a3e966aab1fdc6ddab44e9d36ed91e8c6">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="ac989934222378d7a631679ce774b4a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac989934222378d7a631679ce774b4a27">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#a58496a0bf0c96ba40128a62a0f4f4ded">token_ptr</a> mqtt::async_client::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemqtt.html#a9c4d1d7995dd0788086c71bb3886ed8b">string</a> &amp;&#160;</td>
          <td class="paramname"><em>topicFilter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1iaction__listener.html">iaction_listener</a> &amp;&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmqtt_1_1properties.html">properties</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em> = <code><a class="el" href="classmqtt_1_1properties.html">properties</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests the server unsubscribe the client from a topics. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">topicFilter</td><td>the topic to unsubscribe from. It must match a topicFilter specified on an earlier subscribe. </td></tr>
    <tr><td class="paramname">userContext</td><td>optional object used to pass context to the callback. Use <em>nullptr</em> if not required. </td></tr>
    <tr><td class="paramname">cb</td><td>listener that will be notified when unsubscribe has completed </td></tr>
    <tr><td class="paramname">props</td><td>The MQTT v5 properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token used to track and wait for the unsubscribe to complete. The token will be passed to callback methods if set. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a49680653273875b8bc29baef5b15e870">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="af37da8fd86b399301f2f5d5f3b239efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37da8fd86b399301f2f5d5f3b239efb">&#9670;&nbsp;</a></span>start_consuming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::start_consuming </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start consuming messages. This initializes the client to receive messages through a queue that can be read synchronously. </p>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a16f634cbdff5b35470f2415d7387b660">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a52081856f2406e7d76ccb5450c5d45ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52081856f2406e7d76ccb5450c5d45ca">&#9670;&nbsp;</a></span>stop_consuming()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mqtt::async_client::stop_consuming </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop consuming messages. This shuts down the internal callback and discards any unread messages. </p>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a634e7c4fcc5e5f4efcd39230cde05712">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a931bb5c47e540f66774ae40ae4aa3e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931bb5c47e540f66774ae40ae4aa3e32">&#9670;&nbsp;</a></span>consume_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> mqtt::async_client::consume_message </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the next message from the queue. This blocks until a new message arrives. </p><dl class="section return"><dt>Returns</dt><dd>The message and topic. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a342f8cf339b93580d60287d4f9b8497b">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a34636569902d3fb5994891cc47882a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34636569902d3fb5994891cc47882a81">&#9670;&nbsp;</a></span>try_consume_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mqtt::async_client::try_consume_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Try to read the next message from the queue without blocking. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Pointer to the value to receive the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> is a message was read, <em>false</em> if no message was available. </dd></dl>

<p>Implements <a class="el" href="classmqtt_1_1iasync__client.html#a1d1a19571d557fa2e82a47ee70c0fc4e">mqtt::iasync_client</a>.</p>

</div>
</div>
<a id="a5613bf9226d6ad9b8dcf15a238c18c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5613bf9226d6ad9b8dcf15a238c18c23">&#9670;&nbsp;</a></span>try_consume_message_for() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mqtt::async_client::try_consume_message_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>relTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits a limited time for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Pointer to the value to receive the message </td></tr>
    <tr><td class="paramname">relTime</td><td>The maximum amount of time to wait for a message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if a message was read, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a id="a9534048df4f4b6a0082c60c4fa477c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9534048df4f4b6a0082c60c4fa477c12">&#9670;&nbsp;</a></span>try_consume_message_for() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> mqtt::async_client::try_consume_message_for </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>relTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits a limited time for a message to arrive. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relTime</td><td>The maximum amount of time to wait for a message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to the message that was received. It will be empty on timeout. </dd></dl>

</div>
</div>
<a id="a8bc99d5afd5d35aeb0888ff6c08b9ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc99d5afd5d35aeb0888ff6c08b9ed0">&#9670;&nbsp;</a></span>try_consume_message_until() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mqtt::async_client::try_consume_message_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>absTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits until a specific time for a message to appear. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Pointer to the value to receive the message </td></tr>
    <tr><td class="paramname">absTime</td><td>The time point to wait until, before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if a message was read, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a id="a2d315b0885450ed5f33d05002de5635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d315b0885450ed5f33d05002de5635c">&#9670;&nbsp;</a></span>try_consume_message_until() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemqtt.html#aba3e050696c54f582d9e71b51c661bd0">const_message_ptr</a> mqtt::async_client::try_consume_message_until </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>absTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits until a specific time for a message to appear. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">absTime</td><td>The time point to wait until, before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The message, if read, an empty pointer if not. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad1520136c41afff5cd24bf19d9bf76e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1520136c41afff5cd24bf19d9bf76e5">&#9670;&nbsp;</a></span>token</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classmqtt_1_1token.html">token</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Manage internal list of active tokens </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="async__client_8h_source.html">async_client.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 12 2023 03:05:03 for PahoMqttCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
