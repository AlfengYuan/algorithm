<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PahoMqttCpp: mqtt::thread_queue&lt; T, Container &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="pahologo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PahoMqttCpp
   </div>
   <div id="projectbrief">MQTT C++ Client for POSIX and Windows</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemqtt.html">mqtt</a></li><li class="navelem"><a class="el" href="classmqtt_1_1thread__queue.html">thread_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">mqtt::thread_queue&lt; T, Container &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="thread__queue_8h_source.html">thread_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3541d204c67e24f64b70f26d721bc032"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a3541d204c67e24f64b70f26d721bc032">container_type</a> = Container</td></tr>
<tr class="separator:a3541d204c67e24f64b70f26d721bc032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ec540c315e1284e9df8fe1db9e0837"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> = T</td></tr>
<tr class="separator:a03ec540c315e1284e9df8fe1db9e0837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0258577b49c271d5b330ed81f2d596d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> = typename Container::size_type</td></tr>
<tr class="separator:a0258577b49c271d5b330ed81f2d596d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a69e67e267fb59e0c2902e476a3456e1f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a69e67e267fb59e0c2902e476a3456e1f">thread_queue</a> ()</td></tr>
<tr class="separator:a69e67e267fb59e0c2902e476a3456e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134cc86ccf92a9b1a7843fec5ffc189"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#ae134cc86ccf92a9b1a7843fec5ffc189">thread_queue</a> (size_t cap)</td></tr>
<tr class="separator:ae134cc86ccf92a9b1a7843fec5ffc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd98cafa3aa9b4dbe54baf2a605398e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#abd98cafa3aa9b4dbe54baf2a605398e1">empty</a> () const</td></tr>
<tr class="separator:abd98cafa3aa9b4dbe54baf2a605398e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaabba9627ef1477df3dffd199830f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#adaaabba9627ef1477df3dffd199830f3">capacity</a> () const</td></tr>
<tr class="separator:adaaabba9627ef1477df3dffd199830f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3d5689a5c9de91df58f08751a9a151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a1a3d5689a5c9de91df58f08751a9a151">capacity</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> cap)</td></tr>
<tr class="separator:a1a3d5689a5c9de91df58f08751a9a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf1d7758fc6efe6330d487847b86624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a0bf1d7758fc6efe6330d487847b86624">size</a> () const</td></tr>
<tr class="separator:a0bf1d7758fc6efe6330d487847b86624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af480a8f58a85ac1456232dcbe88b43a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#af480a8f58a85ac1456232dcbe88b43a0">put</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> val)</td></tr>
<tr class="separator:af480a8f58a85ac1456232dcbe88b43a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422932e446605d6df9cad670a3d5f795"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a422932e446605d6df9cad670a3d5f795">try_put</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> val)</td></tr>
<tr class="separator:a422932e446605d6df9cad670a3d5f795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cf1ea025445e65e053c8d6813d8e1b"><td class="memTemplParams" colspan="2">template&lt;typename Rep , class Period &gt; </td></tr>
<tr class="memitem:a51cf1ea025445e65e053c8d6813d8e1b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a51cf1ea025445e65e053c8d6813d8e1b">try_put_for</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> val, const std::chrono::duration&lt; Rep, Period &gt; &amp;relTime)</td></tr>
<tr class="separator:a51cf1ea025445e65e053c8d6813d8e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b33608100ae8050dc5d306e0b8c86f"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:a93b33608100ae8050dc5d306e0b8c86f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a93b33608100ae8050dc5d306e0b8c86f">try_put_until</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> val, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;absTime)</td></tr>
<tr class="separator:a93b33608100ae8050dc5d306e0b8c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10061c6d4eeefa9d6e3002fc2eea6c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#ab10061c6d4eeefa9d6e3002fc2eea6c3">get</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val)</td></tr>
<tr class="separator:ab10061c6d4eeefa9d6e3002fc2eea6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86a422283cfc8c6b95098dcbc495533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#af86a422283cfc8c6b95098dcbc495533">get</a> ()</td></tr>
<tr class="separator:af86a422283cfc8c6b95098dcbc495533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696a704cfcf4333390ee632bc4e069c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a696a704cfcf4333390ee632bc4e069c9">try_get</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val)</td></tr>
<tr class="separator:a696a704cfcf4333390ee632bc4e069c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f762168e9543c7f3988c5a41d4c921b"><td class="memTemplParams" colspan="2">template&lt;typename Rep , class Period &gt; </td></tr>
<tr class="memitem:a4f762168e9543c7f3988c5a41d4c921b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a4f762168e9543c7f3988c5a41d4c921b">try_get_for</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val, const std::chrono::duration&lt; Rep, Period &gt; &amp;relTime)</td></tr>
<tr class="separator:a4f762168e9543c7f3988c5a41d4c921b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d9ff987f6b59b070c7da4e3867cacb"><td class="memTemplParams" colspan="2">template&lt;class Clock , class Duration &gt; </td></tr>
<tr class="memitem:af8d9ff987f6b59b070c7da4e3867cacb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#af8d9ff987f6b59b070c7da4e3867cacb">try_get_until</a> (<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *val, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;absTime)</td></tr>
<tr class="separator:af8d9ff987f6b59b070c7da4e3867cacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5c0a3b1044293fddcd6d100c39069a26"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmqtt_1_1thread__queue.html#a5c0a3b1044293fddcd6d100c39069a26">MAX_CAPACITY</a> = std::numeric_limits&lt;<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&gt;::max()</td></tr>
<tr class="separator:a5c0a3b1044293fddcd6d100c39069a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, class Container = std::deque&lt;T&gt;&gt;<br />
class mqtt::thread_queue&lt; T, Container &gt;</h3>

<p>A thread-safe queue for inter-thread communication.</p>
<p>This is a locking queue with blocking operations. The <a class="el" href="classmqtt_1_1thread__queue.html#af86a422283cfc8c6b95098dcbc495533">get()</a> operations can always block on an empty queue, but have variations for non-blocking (try_get) and bounded-time blocking (try_get_for, try_get_until). </p><dl class="section user"><dt></dt><dd>The default queue has a capacity that is unbounded in the practical sense, limited by available memory. In this mode the object will not block when placing values into the queue. A capacity can bet set with the constructor or, at any time later by calling the <a class="el" href="classmqtt_1_1thread__queue.html#a1a3d5689a5c9de91df58f08751a9a151">capacity(size_type)</a> method. Using this latter method, the capacity can be set to an amount smaller than the current size of the queue. In that case all put's to the queue will block until the number of items are removed from the queue to bring the size below the new capacity. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that the queue uses move semantics to place items into the queue and remove items from the queue. This means that the type, T, of the data held by the queue only needs to follow move semantics; not copy semantics. In addition, this means that copies of the value will <em>not</em> be left in the queue. This is especially useful when creating queues of shared pointers, as the "dead" part of the queue will not hold onto a reference count after the item has been removed from the queue.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type of the items to be held in the queue. </td></tr>
    <tr><td class="paramname">Container</td><td>The type of the underlying container to use. It must support back(), front(), push_back(), pop_front(). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3541d204c67e24f64b70f26d721bc032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3541d204c67e24f64b70f26d721bc032">&#9670;&nbsp;</a></span>container_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html#a3541d204c67e24f64b70f26d721bc032">container_type</a> =  Container</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The underlying container type to use for the queue. </p>

</div>
</div>
<a id="a03ec540c315e1284e9df8fe1db9e0837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ec540c315e1284e9df8fe1db9e0837">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of items to be held in the queue. </p>

</div>
</div>
<a id="a0258577b49c271d5b330ed81f2d596d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0258577b49c271d5b330ed81f2d596d6">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> =  typename Container::size_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type used to specify number of items in the container. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a69e67e267fb59e0c2902e476a3456e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e67e267fb59e0c2902e476a3456e1f">&#9670;&nbsp;</a></span>thread_queue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html">thread_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a queue with the maximum capacity. </p>

</div>
</div>
<a id="ae134cc86ccf92a9b1a7843fec5ffc189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae134cc86ccf92a9b1a7843fec5ffc189">&#9670;&nbsp;</a></span>thread_queue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::<a class="el" href="classmqtt_1_1thread__queue.html">thread_queue</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a queue with the specified capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cap</td><td>The maximum number of items that can be placed in the queue. The minimum capacity is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abd98cafa3aa9b4dbe54baf2a605398e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd98cafa3aa9b4dbe54baf2a605398e1">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine if the queue is empty. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em> if there are no elements in the queue, <em>false</em> if there are any items in the queue. </dd></dl>

</div>
</div>
<a id="adaaabba9627ef1477df3dffd199830f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaabba9627ef1477df3dffd199830f3">&#9670;&nbsp;</a></span>capacity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the capacity of the queue. </p><dl class="section return"><dt>Returns</dt><dd>The maximum number of elements before the queue is full. </dd></dl>

</div>
</div>
<a id="a1a3d5689a5c9de91df58f08751a9a151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3d5689a5c9de91df58f08751a9a151">&#9670;&nbsp;</a></span>capacity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&#160;</td>
          <td class="paramname"><em>cap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the capacity of the queue. Note that the capacity can be set to a value smaller than the current size of the queue. In that event, all calls to <a class="el" href="classmqtt_1_1thread__queue.html#af480a8f58a85ac1456232dcbe88b43a0">put()</a> will block until a sufficient number </p>

</div>
</div>
<a id="a0bf1d7758fc6efe6330d487847b86624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf1d7758fc6efe6330d487847b86624">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the number of items in the queue. </p><dl class="section return"><dt>Returns</dt><dd>The number of items in the queue. </dd></dl>

</div>
</div>
<a id="af480a8f58a85ac1456232dcbe88b43a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af480a8f58a85ac1456232dcbe88b43a0">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put an item into the queue. If the queue is full, this will block the caller until items are removed bringing the size less than the capacity. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a422932e446605d6df9cad670a3d5f795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422932e446605d6df9cad670a3d5f795">&#9670;&nbsp;</a></span>try_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-blocking attempt to place an item into the queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the item was added to the queue, <em>false</em> if the item was not added because the queue is currently full. </dd></dl>

</div>
</div>
<a id="a51cf1ea025445e65e053c8d6813d8e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51cf1ea025445e65e053c8d6813d8e1b">&#9670;&nbsp;</a></span>try_put_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_put_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>relTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to place an item in the queue with a bounded wait. This will attempt to place the value in the queue, but if it is full, it will wait up to the specified time duration before timing out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
    <tr><td class="paramname">relTime</td><td>The amount of time to wait until timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was added to the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a id="a93b33608100ae8050dc5d306e0b8c86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b33608100ae8050dc5d306e0b8c86f">&#9670;&nbsp;</a></span>try_put_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_put_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>absTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to place an item in the queue with a bounded wait to an absolute time point. This will attempt to place the value in the queue, but if it is full, it will wait up until the specified time before timing out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to add to the queue. </td></tr>
    <tr><td class="paramname">absTime</td><td>The absolute time to wait to before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was added to the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a id="ab10061c6d4eeefa9d6e3002fc2eea6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10061c6d4eeefa9d6e3002fc2eea6c3">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a value from the queue. If the queue is empty, this will block indefinitely until a value is added to the queue by another thread, </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af86a422283cfc8c6b95098dcbc495533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86a422283cfc8c6b95098dcbc495533">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a value from the queue. If the queue is empty, this will block indefinitely until a value is added to the queue by another thread, </p><dl class="section return"><dt>Returns</dt><dd>The value removed from the queue </dd></dl>

</div>
</div>
<a id="a696a704cfcf4333390ee632bc4e069c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696a704cfcf4333390ee632bc4e069c9">&#9670;&nbsp;</a></span>try_get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempts to remove a value from the queue without blocking. If the queue is currently empty, this will return immediately with a failure, otherwise it will get the next value and return it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if a value was removed from the queue, <em>false</em> if the queue is empty. </dd></dl>

</div>
</div>
<a id="a4f762168e9543c7f3988c5a41d4c921b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f762168e9543c7f3988c5a41d4c921b">&#9670;&nbsp;</a></span>try_get_for()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_get_for </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>relTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to remove an item from the queue for a bounded amount of time. This will retrieve the next item from the queue. If the queue is empty, it will wait the specified amount of time for an item to arrive before timing out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
    <tr><td class="paramname">relTime</td><td>The amount of time to wait until timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was removed the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<a id="af8d9ff987f6b59b070c7da4e3867cacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d9ff987f6b59b070c7da4e3867cacb">&#9670;&nbsp;</a></span>try_get_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::try_get_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmqtt_1_1thread__queue.html#a03ec540c315e1284e9df8fe1db9e0837">value_type</a> *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>absTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to remove an item from the queue for a bounded amount of time. This will retrieve the next item from the queue. If the queue is empty, it will wait until the specified time for an item to arrive before timing out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Pointer to a variable to receive the value. </td></tr>
    <tr><td class="paramname">absTime</td><td>The absolute time to wait to before timing out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>true</em> if the value was removed from the queue, <em>false</em> if a timeout occurred. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a5c0a3b1044293fddcd6d100c39069a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0a3b1044293fddcd6d100c39069a26">&#9670;&nbsp;</a></span>MAX_CAPACITY</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class Container  = std::deque&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a> <a class="el" href="classmqtt_1_1thread__queue.html">mqtt::thread_queue</a>&lt; T, Container &gt;::MAX_CAPACITY = std::numeric_limits&lt;<a class="el" href="classmqtt_1_1thread__queue.html#a0258577b49c271d5b330ed81f2d596d6">size_type</a>&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum capacity of the queue. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="thread__queue_8h_source.html">thread_queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 12 2023 03:05:04 for PahoMqttCpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
